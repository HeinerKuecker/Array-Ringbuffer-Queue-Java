package com.ble_solutions.ring_buffer;

import java.util.Arrays;
import java.util.NoSuchElementException;

// https://www.google.com/search?q=ringbuffer+array+java
// http://tutorials.jenkov.com/java-performance/ring-buffer.html

// https://www.programiz.com/dsa/circular-queue

/**
 * Version with array access over division rest (modulo).
 *
 * Wenn die Schreibposition und die Leseposition die Feldgrenzen verlassen, werden beide auf den Feldbereich reduziert.
 *
 * When the writing position and the reading position leave the field boundaries, both are reduced to the field area.
 *
 * If the get and the set position leafs the array bound, both values will be reduced to values within array bound.
 *
 * @author Heiner K&uuml;cker
 */
public class IntRingBuffer
{
	private int setIndex;
	private int getIndex;

	private final int[] innerArray;

	/**
	 * Constructor.
	 */
	public IntRingBuffer(
			final int capacity )
	{
		if ( capacity < 1 )
		{
			throw new IllegalArgumentException(
					"capacity " + capacity );
		}

		if ( capacity >= Integer.MAX_VALUE / 2 )
		{
			throw new IllegalArgumentException(
					"capacity " + capacity );
		}

		this.innerArray = new int[ capacity ];
	}

	/**
	 * @return maximal amount of elements to save
	 */
	public int capacity()
	{
		return this.innerArray.length;
	}

	/**
	 * @return current amount of saved elements
	 */
	public int size()
	{
		//throw new RuntimeException( "not implemented" );
		//if ( isEmpty() )
		//{
		//	return 0;
		//}
		//
		//if ( this.getIndex < this.setIndex )
		//{
		//	return this.setIndex - this.getIndex;
		//}
		//
		//// TODO value overflow is possible when size is Integer.MAX_VALUE
		//final int result = ( this.getIndex - this.setIndex ) + capacity();
		//
		//if ( result < 0 || result > capacity() )
		//{
		//	throw new IllegalStateException(
		//			"size " + result );
		//}
		//
		//return result;

		return this.setIndex - this.getIndex;
	}

	public boolean isEmpty()
	{
		//throw new RuntimeException( "not implemented" );
		//return this.setIndex == this.getIndex;
		//return this.setIndex < 0;
		return size() < 1;
	}

	public boolean isFull()
	{
		//throw new RuntimeException( "not implemented" );
		//if ( this.setIndex == capacity() && this.getIndex == 0 )
		//{
		//	return true;
		//}
		//return false;

		//if ( isEmpty() )
		//{
		//	// is only correct when capacity != 0
		//	return false;
		//}

		return this.size() >= capacity();
	}

	public boolean add(
			final int valueToAdd )
	{
		System.out.println( "add " + valueToAdd );

		if ( isFull() )
		{
			return false;
		}

		//if ( isEmpty() )
		//{
		//	setIndex = 0;
		//	getIndex = 0;
		//}
		//else
		//{
		//	//throw new RuntimeException( "not implemented" );
		//	if ( this.setIndex >= capacity() )
		//	{
		//		this.setIndex = 0;
		//	}
		//}
		//
		//innerArray[ setIndex ] = valueToAdd;
		//
		//// TODO value overflow is possible when size is Integer.MAX_VALUE
		////this.setIndex = ( setIndex + 1 ) % capacity();
		//this.setIndex = setIndex + 1;

		innerArray[ this.setIndex % this.capacity() ] = valueToAdd;

		this.setIndex++;

		// here is the trick
		if ( this.getIndex >= this.capacity() &&
				this.setIndex >= this.capacity() )
		{
			this.getIndex %= this.capacity();
			this.setIndex %= this.capacity();
		}

		System.out.println( this );

		return true;
	}

	/**
	 * @return the first element without deleting it
	 */
	public int get()
	{
		//throw new RuntimeException( "not implemented" );
		if ( this.isEmpty() )
		{
			throw new NoSuchElementException();
		}

		return innerArray[ this.getIndex % this.capacity() ];
	}

	/**
	 * @return the first element with deleting it
	 */
	public int take()
	{
		System.out.println( "take" );

		if ( this.isEmpty() )
		{
			throw new NoSuchElementException();
		}

		//final int currentReadIndex = this.getIndex;
		//
		//if ( this.getIndex <= this.setIndex )
		//{
		//	this.getIndex++;
		//
		//	System.out.println( this );
		//
		//	if ( this.setIndex == this.getIndex )
		//	{
		//		// set empty
		//		this.setIndex = -1;
		//
		//		System.out.println( this );
		//	}
		//	else if ( this.getIndex >= capacity() )
		//	{
		//		this.getIndex = 0;
		//	}
		//}
		//else
		//{
		//	throw new RuntimeException( "not implemented" );
		//}
		//
		//final int result = innerArray[ currentReadIndex ];

		final int result = innerArray[ this.getIndex % this.capacity() ];

		this.getIndex++;

		// here is the trick
		if ( this.getIndex >= this.capacity() &&
				this.setIndex >= this.capacity() )
		{
			this.getIndex %= this.capacity();
			this.setIndex %= this.capacity();
		}

		System.out.println( "take " + result );

		return result;
	}

	@Override
	public String toString()
	{
		return
				"IntRingBuffer[" +
				"getIndex=" + getIndex + ", " +
				"setIndex=" + setIndex + ", " +
				"innerArray=" + Arrays.toString(innerArray) +
				"]";
	}

}
