package com.ble_solutions.ring_buffer;

import java.util.Arrays;
import java.util.NoSuchElementException;

// https://www.google.com/search?q=ringbuffer+array+java
// http://tutorials.jenkov.com/java-performance/ring-buffer.html

// https://www.programiz.com/dsa/circular-queue

/**
 * Version with array access over division rest (modulo).
 *
 * Wenn die Schreibposition und die Leseposition die Feldgrenzen verlassen, werden beide auf den Feldbereich reduziert.
 *
 * When the writing position and the reading position leave the field boundaries, both are reduced to the field area.
 *
 * If the get and the set position leafs the array bound, both values will be reduced to values within array bound.
 *
 * <pre>
 * Example: capacity 2
 *
 * +---+---+
 * |   |   |
 * +---+---+
 *   ^
 *   |
 *   +-- getIndex == 0, setIndex == 0
 *
 * Add 1
 * +---+---+
 * | 1 |   |
 * +---+---+
 *   ^   ^
 *   |   |
 *   |   +-- setIndex == 1
 *   +--- getIndex == 0
 *
 * Add 2
 * +---+---+
 * | 1 | 2 |
 * +---+---+
 *   ^
 *   |
 *   +-- getIndex == 0, setIndex == 2 ( setIndex % 2 == 0 )
 *
 * Take 1
 * +---+---+
 * | 1 |   |
 * +---+---+
 *   ^   ^
 *   |   |
 *   |   +-- getIndex == 1
 *   +--- setIndex == 2 ( setIndex % 2 == 0 )
 *
 * Add 3
 * +---+---+
 * | 3 | 2 |
 * +---+---+
 *       ^
 *       |
 *       +-- getIndex == 1, setIndex == 3 ( setIndex % 2 == 1 )
 *
 * Take 2
 * +---+---+
 * | 3 |   |
 * +---+---+
 *   ^   ^
 *   |   |
 *   |   +-- setIndex == 3 ( setIndex % 2 == 1 )
 *   +-- getIndex == 2 ( getIndex % 2 == 0 )
 *
 * Reduce Index
 * +---+---+
 * | 3 |   |
 * +---+---+
 *   ^   ^
 *   |   |
 *   |   +-- setIndex == 1
 *   +-- getIndex == 0
 *
 * Take 3
 * +---+---+
 * |   |   |
 * +---+---+
 *       ^
 *       |
 *       +- getIndex == 1, setIndex == 1
 *
 * </pre>
 *
 * @author Heiner K&uuml;cker
 */
public class IntRingBuffer
{
	private int setIndex;
	private int getIndex;

	private final int[] innerArray;

	/**
	 * Constructor.
	 */
	public IntRingBuffer(
			final int capacity )
	{
		if ( capacity < 1 )
		{
			throw new IllegalArgumentException(
					"capacity " + capacity );
		}

		if ( capacity >= Integer.MAX_VALUE / 2 )
		{
			throw new IllegalArgumentException(
					"capacity " + capacity );
		}

		this.innerArray = new int[ capacity ];
	}

	/**
	 * @return maximal amount of elements to save
	 */
	public int capacity()
	{
		return this.innerArray.length;
	}

	/**
	 * @return current amount of saved elements
	 */
	public int size()
	{
		return this.setIndex - this.getIndex;
	}

	public boolean isEmpty()
	{
		return size() < 1;
	}

	public boolean isFull()
	{
		return this.size() >= capacity();
	}

	public boolean add(
			final int valueToAdd )
	{
		//System.out.println( "add " + valueToAdd );

		if ( isFull() )
		{
			return false;
		}

		innerArray[ this.setIndex % this.capacity() ] = valueToAdd;

		this.setIndex++;

		//System.out.println( this );

		return true;
	}

	/**
	 * @return the first element without deleting it
	 */
	public int get()
	{
		if ( this.isEmpty() )
		{
			throw new NoSuchElementException();
		}

		return innerArray[ this.getIndex % this.capacity() ];
	}

	/**
	 * @return the first element with deleting it
	 */
	public int take()
	{
		//System.out.println( "take" );

		if ( this.isEmpty() )
		{
			throw new NoSuchElementException();
		}

		final int result = innerArray[ this.getIndex % this.capacity() ];

		this.getIndex++;

		// here is the trick
		if ( this.getIndex >= this.capacity() )
		{
			this.getIndex %= this.capacity();
			this.setIndex %= this.capacity();
		}

		//System.out.println( "take " + result );

		return result;
	}

	@Override
	public String toString()
	{
		return
				"IntRingBuffer[" +
				"getIndex=" + getIndex + ", " +
				"setIndex=" + setIndex + ", " +
				"innerArray=" + Arrays.toString( innerArray ) +
				"]";
	}

}
